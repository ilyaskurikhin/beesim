#include <Env/Env.hpp>

#include <Env/Flower.hpp>
#include <Env/FlowerGenerator.hpp>

bool ENV_VERBOSE(true);

Env::Env() :
    world_(new World()), flower_generator_(new FlowerGenerator)
{
    logEvent("Env", "generating environment");
    reloadConfig();

    // new hives and flowers are generated by calling init from above
    // fix generation in cfg file
}

Env::~Env()
{
    logEvent("Env", "destroying environment");
    delete world_;

    // delete all flowers
    for (size_t i = 0; i < flowers_.size(); ++i) {
        delete flowers_[i];
    }
    flowers_.clear();

    // delete all hives
    for (size_t i = 0; i < hives_.size(); ++i) {
        delete hives_[i];
    }
    hives_.clear();

}

void
Env::regenerate()
{
    logEvent("Env", "regenerating objects");

    // initialises attributes from the json file
    auto const& initial = getAppConfig()["simulation"]["env"]["initial"];

    int num_hives(initial["hive"]["count"].toInt());
    int num_flowers(initial["flower"]["count"].toInt());

    int num_tries_hives(initial["hive"]["max failures"].toInt());
    int num_tries_flowers(initial["flower"]["max failures"].toInt());

    double hive_min_size(initial["hive"]["size"]["min"].toDouble());
    double hive_max_size(initial["hive"]["size"]["max"].toDouble());

    double flower_min_size(initial["flower"]["size"]["min"].toDouble());
    double flower_max_size(initial["flower"]["size"]["max"].toDouble());

    // try to add a hive at a uniform position in world
    // count the number of tries if the hive cannot be placed
    for (int i = 0; i < num_hives; ++i) {
        int num_tries(0);
        bool placed(false);
        while (!placed && num_tries < num_tries_hives) {
            Vec2d position;
            position.x = uniform(0.0, getWorldSize().x);
            position.y = uniform(0.0, getWorldSize().y);

            if (addHiveAt(position, uniform(hive_min_size, hive_max_size)))
                placed = true;
            else
                ++num_tries;
        }
    }

    // do the same for flowers
    for (int i = 0; i < num_flowers; ++i) {
        int num_tries(0);
        bool placed(false);
        while (!placed && num_tries < num_tries_flowers) {
            Vec2d position;
            position.x = uniform(0.0, getWorldSize().x);
            position.y = uniform(0.0, getWorldSize().y);

            int num_tries(0);
            if (addFlowerAt(position, uniform(flower_min_size, flower_max_size)))
                placed = true;
            else
                ++num_tries;
        }
    }
}

void
Env::update(sf::Time dt)
{
    // update du generateur
    if ((flowers_.size() < max_flowers_)
        && (getAppConfig()["simulation"]["flower generator"]["active"].toBool())) {
        flower_generator_->update(dt);
    }

    // iterate through flowers
    for (size_t i = 0; i < flowers_.size(); ++i) {
        // flowers are updated
        // new flowers are drawn in next draw cycle
        flowers_[i]->update(dt);

        // check if flower is dead
        if (flowers_[i]->getPollen() <= 0) {
            // remove dead flower
            delete flowers_[i];
            flowers_[i] = nullptr;
        }
    }
    // remove empty locations
    flowers_.erase(std::remove(flowers_.begin(), flowers_.end(), nullptr),
                   flowers_.end());

    // iterate through hives
    for (size_t i = 0; i < hives_.size(); ++i) {
        // hives are updated
        hives_[i]->update(dt);

        // check if there is no more nectar and no more bees
        if (hives_[i]->getNectar() <= 0 && hives_[i]->getNumBees() == 0) {
            // remove dead hive
            delete hives_[i];
            hives_[i] = nullptr;
        }
    }
    // remove empty locations
    hives_.erase(std::remove(hives_.begin(), hives_.end(), nullptr),
                 hives_.end());

    // iterate through caves
    for (size_t i = 0; i < caves_.size(); ++i) {
        // update the caves
        caves_[i]->update(dt);

        // check if there is still a bear in it
        if (caves_[i]->getBear() == nullptr) {
            // remove empty caves
            delete caves_[i];
            caves_[i] = nullptr;
        }
    }
    // remove empty locations
    caves_.erase(std::remove(caves_.begin(), caves_.end(), nullptr),
                 caves_.end());
}

void
Env::drawOn(sf::RenderTarget& target) const
{
    world_->drawOn(target);

    // draw flowers
    for (size_t i = 0; i < flowers_.size(); ++i) {
        flowers_[i]->drawOn(target);
    }

    // draw hives
    for (size_t i = 0; i < hives_.size(); ++i) {
        hives_[i]->drawOn(target);

    }

    // draw caves
    for (size_t i = 0; i < caves_.size(); ++i) {
        caves_[i]->drawOn(target);

    }
}

void
Env::drawDebug(sf::RenderTarget& target) const
{

    // draw hives
    for (size_t i = 0; i < hives_.size(); ++i) {
        hives_[i]->drawDebug(target);

    }



    // get cursor position
    Vec2d position = getApp().getCursorPositionInView();
    if (world_->isInWorld(position)) {
        bool isShowing(false);
        std::string valueString("empty");
        sf::Color color(sf::Color::White);

        // check for flowers
        for (size_t i = 0; i < flowers_.size(); ++i) {
            if (*(flowers_[i]) > position) {
                isShowing = true;
                valueString = to_nice_string(flowers_[i]->getPollen());
                color = sf::Color::Yellow;
            }
        }

        // otherwise show ambient humidity
        if (!isShowing && getAppConfig()["simulation"]["world"]["show humidity"].toBool()) {
            valueString = to_nice_string(world_->getHumidity(position));
            color = sf::Color::Red;
            isShowing = true;
        }

        if (isShowing) {
            sf::Text text = buildText(valueString, position, getAppFont(),
                                      debug_text_size_, color);
            target.draw(text);
        }

    }
}

void
Env::reset()
{
    logEvent("Env", "resetting environment");

    world_->reset(true);

    // iterate on flowers and delete them
    for (size_t i = 0; i < flowers_.size(); ++i) {
        delete flowers_[i];
    }
    flowers_.clear();
    flower_generator_->reset();

    // iterate on hives and delete them
    for (size_t i = 0; i < hives_.size(); ++i) {
        delete hives_[i];
    }
    hives_.clear();

    // iterate on caves and delete them
    for (size_t i = 0; i < caves_.size(); ++i) {
        delete caves_[i];
    }
    caves_.clear();
}

void
Env::reloadConfig()
{
    logEvent("Env", "reloading config");

    // get variables from configuration
    flower_manual_radius_ =
        getAppConfig()["simulation"]["env"]["initial"]["flower"]["size"]["manual"].toDouble();
    flower_max_nectar_ =
        getAppConfig()["simulation"]["env"]["initial"]["flower"]["nectar"]["max"].toDouble();
    flower_min_nectar_ =
        getAppConfig()["simulation"]["env"]["initial"]["flower"]["nectar"]["min"].toDouble();

    max_flowers_ = getAppConfig()["simulation"]["env"]["max flowers"].toInt();
    max_caves_ = getAppConfig()["simulation"]["env"]["max caves"].toInt();

    hive_manual_radius_ =
        getAppConfig()["simulation"]["env"]["initial"]["hive"]["size"]["manual"].toDouble();

    debug_text_size_ = 12;
    /* * (getAppConfig()["simulation"]["world"]["size"].toDouble()
         / getAppConfig()["simulation"]["world"]["cells"].toDouble());
    */
    hiveable_factor_ =
        getAppConfig()["simulation"]["env"]["initial"]["hive"]["hiveable factor"].toDouble();

    cave_manual_radius_ =
        getAppConfig()["simulation"]["env"]["initial"]["cave"]["size"]["manual"].toDouble();
}

void
Env::loadWorldFromFile()
{
    world_->loadFromFile();
    regenerate();
}

void
Env::saveWorldToFile() const
{
    world_->saveToFile();
}

const Vec2d&
Env::getWorldSize() const
{
    return world_->getWorldSize();
}

double
Env::getHumidity(const Vec2d& position) const
{
    return world_->getHumidity(position);
}

bool
Env::isGrowable(const Vec2d& position) const
{
    return world_->isGrass(position);
}

bool
Env::isFlyable(const Vec2d& position) const
{
    return world_->isFlyable(position);
}

bool
Env::isPlaceable(const Vec2d& position, double radius) const
{
    // if there is grass at the position
    if (world_->isGrass(position)) {
        Collider object(position, radius);

        // check if the future hive is not colliding to a hive or a cave
        if (getCollidingHive(object) == nullptr
            && getCollidingCave(object) == nullptr) {
            return true;
        }
    }
    return false;
}

bool
Env::isHiveable(const Vec2d& position, double radius) const
{
    std::array<double, 8> v(calculateScanRange(position, radius));

    if (!world_->isGrassArea(Vec2d(v[0], v[2]), Vec2d(v[1], v[3]))
        || !world_->isGrassArea(Vec2d(v[4], v[2]), Vec2d(v[5], v[3]))
        || !world_->isGrassArea(Vec2d(v[0], v[6]), Vec2d(v[1], v[7]))
        || !world_->isGrassArea(Vec2d(v[4], v[6]), Vec2d(v[5], v[7]))) {
        return false;
    } else {
        return true;
    }
}

bool
Env::isCavePlaceable(const Vec2d& position, double radius) const
{
    // check if there is grass or rock at position
    if (world_->isGrass(position) or world_->isRock(position)) {
        Collider object(position, radius);

        // check if the future cave is not colliding to a hive or a cave
        if (getCollidingHive(object) == nullptr
            && getCollidingCave(object) == nullptr) {
            return true;
        }
    }
    return false;
}

bool
Env::isWalkable(const Vec2d& position) const
{
    return world_->isWalkable(position);
}

bool
Env::canAddFlower()
{
    if (flowers_.size() < max_flowers_)
        return true;
    else
        return false;
}

bool
Env::addFlowerAt(const Vec2d& position)
{
    return addFlowerAt(position, flower_manual_radius_);
}

bool
Env::addFlowerAt(const Vec2d& position, double size)
{
    // check if flower can be made at position
    if ((flowers_.size() < max_flowers_) && (isPlaceable(position, size))) {
        // set a random number of pollen
        double pollen = uniform(flower_min_nectar_, flower_max_nectar_);
        flowers_.push_back(new Flower(position, size, pollen));
        return true;
    } else {
        return false;
    }
}

void
Env::drawFlowerZone(sf::RenderTarget& target, const Vec2d& position)
{
    if (world_->isGrass(position)) {
        sf::CircleShape shape = buildAnnulus(position, flower_manual_radius_,
                                             sf::Color::Green, 5.0);
        target.draw(shape);
    } else {
        sf::CircleShape shape = buildAnnulus(position, flower_manual_radius_,
                                             sf::Color::Red, 5.0);
        target.draw(shape);
    }
}

bool
Env::addHiveAt(const Vec2d& position)
{
    return addHiveAt(position, hive_manual_radius_);
}

bool
Env::addHiveAt(const Vec2d& position, double size)
{
    // check if there is grass at position and object is placeabl
    if (isPlaceable(position, size) && isHiveable(position,size)) {
        hives_.push_back(new Hive(position, size));
        return true;
    } else {
        return false;
    }
}

bool
Env::addCaveAt(const Vec2d& position)
{
    return addCaveAt(position, cave_manual_radius_);
}

bool
Env::addCaveAt(const Vec2d& position, double size)
{
    // if there is not too much caves, one can be placed if the cave is placeable at position
    if (caves_.size() < max_caves_) {
        if (isCavePlaceable(position, size)) {
            caves_.push_back(new Cave(position, size));
            return true;
        }
    }
    return false;
}

void
Env::drawHiveableZone(sf::RenderTarget& target, const Vec2d& position,
                      double radius) const
{
    sf::Color color;
    sf::Color fillColor;
    fillColor.a = 0;

    if (!isHiveable(position, hive_manual_radius_)) {
        color = sf::Color::Blue;
    } else if (!isPlaceable(position, hive_manual_radius_)) {
        color = sf::Color::Red;
    } else {
        color = sf::Color::Green;
    }

    std::array<double, 8> v(calculateScanRange(position, radius));

    sf::RectangleShape shape(
        buildRectangle(Vec2d(v[0], v[2]), Vec2d(v[1], v[3]), color, 5.0,
                       fillColor));
    target.draw(shape);
    sf::RectangleShape h_shape(
        buildRectangle(Vec2d(v[4], v[2]), Vec2d(v[5], v[3]), color, 5.0,

                       fillColor));
    target.draw(h_shape);
    sf::RectangleShape v_shape(
        buildRectangle(Vec2d(v[0], v[6]), Vec2d(v[1], v[7]), color, 5.0,
                       fillColor));
    target.draw(v_shape);
    sf::RectangleShape d_shape(
        buildRectangle(Vec2d(v[4], v[6]), Vec2d(v[5], v[7]), color, 5.0,
                       fillColor));
    target.draw(d_shape);
}

void
Env::drawHiveableZone(sf::RenderTarget& target, const Vec2d& position) const
{
    drawHiveableZone(target, position, hive_manual_radius_);
}

Hive*
Env::getCollidingHive(const Collider& body) const
{
    // iterate on hives and check if body is colliding to one of them
    for (size_t i(0); i < hives_.size(); ++i) {
        Collider collidingHive(hives_[i]->getPosition(),
                               (hive_manual_radius_ * hiveable_factor_));

        if (collidingHive.isColliding(body)) {
            // return the colliding hive
            return hives_[i];
        }
    }
    return nullptr;
}

Flower*
Env::getCollidingFlower(const Collider& body) const
{
    // iterate on flowers and check if body is colliding to one of them
    for (size_t i(0); i < flowers_.size(); ++i) {
        if (flowers_[i]->isColliding(body)) {
            // return the colliding flower
            return flowers_[i];
        }
    }
    return nullptr;
}

Cave*
Env::getCollidingCave(const Collider& body) const
{
    // iterate on caves and check if body is colliding to one of them
    for (size_t i(0); i < caves_.size(); ++i) {
        if (caves_[i]->isColliding(body)) {
            // return the colliding cave
            return caves_[i];
        }
    }
    return nullptr;
}

Bee*
Env::getBeeAt(const Vec2d& position) const
{
    for (size_t i = 0; i < hives_.size(); ++i) {
        Bee* bee = hives_[i]->getBeeAt(position);
        if (bee) {
            return bee;
        }
    }
    return nullptr;
}

Bear*
Env::getBearAt(const Vec2d& position) const
{
    for (size_t i = 0; i < caves_.size(); ++i) {
        Bear* bear = caves_[i]->getBearAt(position);
        if (bear)
            return bear;
    }
    return nullptr;
}

Movable*
Env::getAnimalAt(const Vec2d& position) const
{
    Movable* tracked;
    tracked = getBeeAt(position);
    if (tracked)
        return tracked;

    tracked = getBearAt(position);
    if (tracked)
        return tracked;

    return nullptr;
}

int
Env::getNumScouts() const
{
    int numScouts(0);
    for (size_t i = 0; i < hives_.size(); ++i) {
        numScouts += hives_[i]->getNumScouts();
    }
    return numScouts;
}

int
Env::getNumWorkers() const
{
    int numWorkers(0);
    for (size_t i = 0; i < hives_.size(); ++i) {
        numWorkers += hives_[i]->getNumWorkers();
    }
    return numWorkers;
}

double
Env::getTextSize()
{
    return debug_text_size_;
}

std::array<double, 8>
Env::calculateScanRange(const Vec2d& position, double radius) const
{
    Vec2d worldSize = getWorldSize();

    //
    //
    //        ---------------------------------------------
    //        |     | 2|                                  |
    //        |     ----                                  |
    //        |     v_bottom     top                      |
    //        | top             -----               top   |
    //        |-                |   |               ------|
    //        | |          left | 3 | right         |     |
    //        |1| h_left        |   |         right |  1  | left
    //        | |               -----               |     |
    //        |-                bottom              ------|
    //        |bottom                              bottom |
    //        |      top                                  |
    //        |     ----                                  |
    //        |     | 2|                                  |
    //        ---------------------------------------------
    //
    //        1 : wrapping on side
    //        2 : wrapping on top / bottom
    //        3 : no wrappin
    //        4 : wrapping on both side and top / bottom
    //


    // boundaries of the middle box
    double left, right, top, bottom;

    // overflow boundaries for extra boxes
    double h_left(-5), h_right(-5); // horizontal
    double v_top(-5), v_bottom(-5); // vertical

    if (!world_->isInWorld(position))
        return {0,0,0,0};

    // get left boundary
    left = position.x - radius;
    if (left < 0) {
        h_right = left + worldSize.x;
        h_left = worldSize.x;
    }

    // get right boundary
    right = position.x + radius;
    if (right > worldSize.x) {
        h_right = right - worldSize.x;
        h_left = 0;
    }

    // get top boundary
    top = position.y - radius;
    if (top < 0) {
        v_bottom = worldSize.y;
        v_top = top + worldSize.y;
    }

    // get bottom boundary
    bottom = position.y + radius;
    if (bottom > worldSize.y) {
        v_bottom = 0;
        v_top = bottom - worldSize.y;
    }

    return {left, right, top, bottom, h_left, h_right, v_top, v_bottom};
}

std::unordered_map<std::string, double>
Env::fetchData(std::string graph) const
{
    std::unordered_map<std::string, double> new_data;

    // get relevant data for graph(s)
    if (graph == s::GENERAL) {
        new_data[s::FLOWERS] = flowers_.size();
        new_data[s::HIVES] = hives_.size();
        new_data[s::SCOUTS] = getNumScouts();
        new_data[s::WORKERS] = getNumWorkers();
    }
    return new_data;
}
